<p>ORM в mzz предназначен для упрощения работы с данными в БД. Стандартные классы, входящие в ORM обладают минимально необходимым функционалом - CRUD (Create, Retrieve, Update, Delete).</p>
<p>ORM построен на базе <a href="http://wiki.agiledev.ru/doku.php?id=ooad:dp:data_mapper">The Data Mapper Pattern</a>. Вкратце: в контектсте этого паттерна мы оперируем двумя терминами - маппер и доменный объект (ДО). Упрощённо: доменный объект - контейнер для данных, маппер - класс для заполнения ДО данными. Все действия по модификации также осуществляются через маппер.</p>
<p>Также отметим, что ДО является отображением данных приложения и данных в БД (в пределах 1 сеанса). Из этого следует, что до тех пор, пока объект не был сохранён специальным методом маппера, он будет выдавать "старые" данные (именно те, которые сейчас находятся в БД). Проиллюстрирую это на примере:</p>
<!-- php code 3 -->
<p>DO лежат в корневом каталоге каждого модуля, мапперы - в подкаталоге <code>mappers</code>.<br />
Для функционирования The Data Mapper Pattern также нужен файл map - в котором находится схема (описание структуры) данных. Файлы map располагаются в подкаталоге <code>maps</code> каталога модуля. В этом файле описаны имена полей, которые есть в таблице, которую отражает ДО, имена акцессоров и мутаторов, а также некоторая другая инфORMация. Структура данного файла выглядит так:<br />
<<code ini>>
[Имя поля]
accessor = "имя акцессора"
mutator = "имя мутатора"
...
&lt;другие опции&gt;
<</code>>
<p>О назначении акцессора и мутатора вы можете узнать, прочитав статью по ссылке выше.</p>
<p>Возможные дополнительные опции:</p>
<ul>
        <li><p>
                <em>once</em> - eсли данная опция установлена в "true", то это поле может быть установлено лишь 1 раз. Пользователем при создании объекта, либо маппером - при создании объекта по запросу пользователя. Примеры использования: устанавливается для Primary Key (например: id).</p>
        </li>
        <li>
                <em>owns</em> - используется для создания отношений 1:1.<br />
                Синтаксис:
                <<code ini>>
                        owns = "имя_объекта.поле"
                <</code>>
                Пример:
                <<code ini>>
[related_id]
accessor = "getRelated"
mutator = "setRelated"
owns = "related.id"
                <</code>>
                В приведённом примере текущая таблица (а соответственно и объект) связана отношением 1:1 с таблицей <code>related</code>. Связь осуществляется между полем <code>related_id</code> текущей таблицы и полем <code>id</code> таблицы <code>related</code>.<br />
                В полученном согласно этой схеме ДО данные в свойстве <code>related_id</code> (получаемое с помощью мутатора <code>getRelated</code>), будет являться инстанцией класса <code>related</code> с нужными данными.<br />
                Пример клиентского кода:
                <!-- php code 1 -->
                <p>Вышеприведённый пример вернёт id присоединяемого объекта.</p>
        </li>
        <li>
                <em>hasMany</em> - опция, аналогичная owns, с тем лишь различием, что в текущей таблице для связи используется другое поле, например Primary Key, а также в результате выборки возвращается не один, а коллекция объектов.<br />
                Пример:
                <<code ini>>
[related_id]
accessor = "getRelated"
mutator = "setRelated"
hasMany = "id->related2.relate_id"
                <</code>>
                В этом примере <code>related2.relate_id</code> несут ту же смысловую нагрузку что и для опции <code>owns</code>, а <code>id</code> (после которого должен следовать знак "->") - обозначает имя поля, по которому происходит связывание<br />
                <p>Пример клиентского кода абсолютно аналогичен примеру из owns.</p>
        </li>
        <li>
                <em>section, module, do</em> - данные свойства используются совместно с owns и hasMany для того, чтобы указать, в контексте какой секции, какого модуля и какого типа должен создаваться присоединяемый DO.<br />
                Это можно использовать например в случае, когда у вас список пользователей находится в таблице <code>user_user</code>, таблица с новостями - <code>news_news</code>. В таблице <code>news</code> поле <code>editor</code> определяет последнего исправлявшего новость. Текущая секция - <code>news</code>. Для этой ситуации файл map для DO <code>news</code> может выглядеть следующим образом:
                <<code ini>>
[editor]
accessor = "getEditor"
mutator = "setEditor"
owns = "user.id"
section = "user"
module = "user"
do = "other_user"
                <</code>>
                Пример клиентского кода:
                <!-- php code 2 -->
                <p>Пример вернёт имя последнего исправлявшего новость. Причём объект, возвращаемый по
                <<code php>>$news->getEditor();<</code>>
                будет инстанцией класса <i>other_user</i>.
                </p>
        </li>
        <li>
                <em>decorateClass</em> - данное свойство устанавливает какой сервисный класс использовать для декорирования свойства<br />
	Например, вам необходимо хешировать пароль:                
                <<code ini>>
[password]
accessor = "getPassword"
mutator = "setPassword"
decorateClass = "md5PasswordHash"
                <</code>>
        </li>
        <li>
                <em>alias</em> - свойство указывает, какое соединение использовать мапперу.
  
        </li>
</ul>
<p>Рассмотрим основные методы для работы с мапперами:</p>
<ul>
        <li><p>
                <em>save($object)</em> - сохранение объекта $object.</p>
        </li>
        <li><p>
                <em>create()</em> - создание объекта.</p>
        </li>
        <li><p>
                <em>delete($id)</em> - удаление объекта, в качестве идентификатора используется первичный ключ $id.</p>
        </li>
</ul>
<p>Также для удобства имеется ряд методов для получения записей:</p>
<ul>
        <li><p>
                <em>searchByKey($id)</em> - поиск объекта по первичному ключу.</p>
        </li>
        <li><p>
                <em>searchByKeys($id)</em> - поиск объектов по первичным ключам. В качестве аргумента передаётся массив.</p>
        </li>
        <li><p>
                <em>searchOneByField($name, $value)</em> - поиск объекта по значению $value поля $field.</p>
        </li>
        <li><p>
                <em>searchAllByField($name, $value)</em> - поиск объектов по значению $value поля $field.</p>
        </li>
        <li><p>
                <em>searchOneByCriteria(criteria $criteria)</em> - поиск объекта по критерию.</p>
        </li>
        <li><p>
                <em>searchAllByCriteria(criteria $criteria)</em> - поиск объектов по критерию.</p>
        </li>
        <li><p>
                <em>searchAll($orderCriteria = null)</em> - выборка всех объектов. В качестве аргумента может быть передан критерий для сортировки.</p>
        </li>
</ul>
<p>Естественно, что в ваших мапперах вы можете расширить данный список методов для поиска. Так например searchByLogin (метод для поиска пользователя по его логину) будет выглядеть следующим образом:</p>
<!-- php code 4 -->
<<note>>Экранировать значения, передаваемые в аргументах, не нужно. За вас это сделает генератор запросов.<</note>>
<<note>>О работе с критериями можно узнать в <a href="db.queries.html#db.queries">соответствующем разделе</a>.<</note>>