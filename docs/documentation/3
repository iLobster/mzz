3.1.1.
Шаблоны являются одной из View-составляющих парадигмы MVC, на основе которой построен mzz. Другой составляющей является PHP-класс, определяющий конкретный шаблон и запускающий этот шаблон на выполнение.
В качестве обработчика шаблонов используется Smarty. Шаблоны располагаются в папке с проектом в директории templates. В mzz образно все шаблоны делятся на 2 вида: "активные" и "пассивные".
Первые служат своеобразной точкой входа в приложение. Эти шаблоны располагаются в корне папки templates и имеют имена вроде: act.module.action.tpl
Где module и action - имя модуля и действия соответственно, который будет запущен этим шаблоном (это просто соглашение для удобства, в действительности любой шаблон может запускать любой модуль). Активный шаблон может быть запущен frontController-ом (ссылка на описание). 
На один запрос пользователя может быть запущен лишь один "активный" шаблон и любое количество "пассивных" шаблонов.
"Пассивные" шаблоны, в свою очередь, могут быть вызваны как "активными" шаблонами в процессе запуска приложения, так и другими "пассивными" шаблонами. Их целью является отображение данных, полученных из модели (в контексте парадигмы MVC), в требуемом виде. 

3.1.2.
Функция {load} предназначена для запуска модулей из шаблонов. Этот метод назовём "стратегией вытягивания", в которой шаблоны (по сути клиентский код) сами определяют, какие данные нужно получить и отобразить пользователю. За счёт этого добивается удобство и гибкость построенных на подобных системах, использующих данный принцип, приложений.

Синтаксис функции:
{load module="" action="" args="" section=""}
Описание аргументов:
        - module: имя загружаемого модуля, обязательный параметр;
        - action: имя действия загружаемого модуля, обязательный параметр;
        - args: список аргументов, разделенных знаком "/", используемых в запускаемом модуле;
        - section: имя раздела, в контексте которого будет запущен модуль, за счёт чего достигается возможность обслуживания модулем различных разделов, обладающих одинаковой функциональностью.

Примеры:
{load module="news" action="list"} загрузит модуль новости и выполнит действие "list"
{load module="news" action="view" args="15" section="mainnews"} загрузит модуль новости и отобразит новость с ID 15 секции mainnews

3.1.3.
Функция {add} предназначена для подключения внешних файлов с js и css. Это необходимо для того, чтобы в результирующем документе, который будет служить результатом запроса клиента, подключение данных ресурсов происходило в одном месте централизованно, а не разрозненно по всему документу. Также функция не допускает включение не нужных файлов и повторного включения одного и того же файла.

Синтаксис функции:
{add file="" tpl=""}
Описание аргументов:
        - file: имя подключаемого файла, обязательный аргумент (*)
        - tpl: имя шаблона, определяющего формат, с помощью которого имя подключаемого файла будет оформлено специальным образом, результат обработки которого будет включён в ответ пользователю

Примеры использования:
{add file="style.css"}
{add file="js.css" tpl="some_other_template.tpl"}

3.1.4
В шаблон часто требуется вставить ссылку. Для генерации адреса ссылки используется функция {url}. Результатом работы этой функции является URL, который собран из:
 - текущего протокола (HTTP/HTTPS);
 - адреса HTTP-хоста (HTTP_HOST);
 - порта сервера, если используется не 80 порт;
 - дополнительного пути, который указан в конфигурационной константе SITE_PATH;
 - секции;
 - параметров, если они были указаны;
 - действия;
Результатом вызова функции {url} без аргументов будет текущий URL (прим.: на данный момент - текущий PATH)

Синтаксис функции:
{url section="" action="" params=""}
Описание аргументов:
        - section: имя секции, на которую будет ссылаться URL;
        - action: действие для указанного section;
        - params: дополнительные параметры, разделитель - знак "/";
Примеры использования:
{url}
{url section="guestbook" action="edit" params="12"}

3.2.
3.2.1.
Тулкит


3.7
ОРМ

Определение ОРМ

ОРМ в мзз предназначен для упрощения работы с данными в БД. Стандартные классы, входящие в ОРМ обладают минимально необходимым функционалом - CRUD (Create, Retrieve, Update, Delete).
ОРМ построен на базе The Data Mapper Pattern (http://wiki.agiledev.ru/doku.php?id=ooad:dp:data_mapper). Вкратце: в контектсте этого паттерна мы оперируем двумя терминами - маппер и доменный объект (ДО). Упрощённо: доменный объект - контейнер для данных, маппер - класс для заполнения ДО данными.Все действия по модификации также осуществляются через маппер.
ДО лежат в корневом каталоге каждого модуля, мапперы - в подкаталоге mappers.
Для функционирования The Data Mapper Pattern также нужен файл map - в котором находится схема (описание структуры) данных. Файлы map располагаются в подкаталоге maps каталога модуля. В этом файле описаны имена полей, которые есть в таблице, которую отражает ДО, имена акцессоров и мутаторов, а также некоторая другая информация. Структура данного файла выглядит так:

[Имя поля]
accessor = "имя акцессора"
mutator = "имя мутатора"
...
<другие опции>

О назначении акцессора и мутатора вы можете узнать, прочитав статью по ссылке выше.
Возможные дополнительные опции:

        once
        Если данная опция установлена в "true", то это поле может быть установлено лишь 1 раз. Пользователем при создании объекта, либо маппером - при создании объекта по запросу пользователя. Примеры использования: устанавливается для Primary Key (например: id).
        
        owns
        Используется для создания отношений 1:1.
        Синтаксис:
        owns = "имя_объекта.поле"
        Пример:
        [related_id]
        accessor = "getRelated"
        mutator = "setRelated"
        owns = "related.id"
        В приведённом примере текущая таблица (а соответственно и объект) связана отношением 1:1 с таблицей related. Связь осуществляется между полем related_id текущей таблицы и полем id таблицы related.
        В полученном согласно этой схеме ДО данные в свойстве related_id (получаемое с помощью мутатора getRelated), будет являться инстанцией класса related с нужными данными.
        Пример клиентского кода:
        $DO->getRelated()->getId()
        Вышеприведённый пример вернёт id присоединяемого объекта.
        
        has
        Опция, аналогичная owns, с тем лишь различием, что в текущей таблице для связи используется другое поле, например Primary Key.
        Пример:
        [related_id]
        accessor = "getRelated"
        mutator = "setRelated"
        has = "id->related2.relate_id"
        
        В этом примере related2.relate_id несут ту же смысловую нагрузку что и для опции owns, а id (после которого должен следовать знак ->) - обозначает имя поля, по которому происходит связывание
        
        Пример клиентского кода абсолютно аналогичен примеру из owns.
        
        section
        Данное свойство используется совместно с owns и has для того, чтобы указать, в контексте какой секции должен создаваться присоединяемый ДО.
        Это можно использовать например в случае, когда у вас список пользователей находится в таблице user_user, таблица с новостями - news_news. В таблице news поле editor определяет последнего исправлявшего новость. Текущая секция - news. Для этой ситуации файл map для ДО news может выглядеть следующим образом:
        [editor]
        accessor = "getEditor"
        mutator = "setEditor"
        owns = "user.id"
        section = "user"
        Пример клиентского кода:
        
        $news->getEditor()->getLogin();
        Пример вернёт имя последнего исправлявшего новость.